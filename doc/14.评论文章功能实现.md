上篇我们实现了用户注册功能，至此用户管理模块已经全部完成。

接下来我们来实现博客的另一重要功能：文章评论。

有了文章管理的知识积累，实现评论管理功能就比较轻松了。

按照MTV的模型分别编写对应的模块。

# 准备工作
## 创建评论管理模块app
```sh
python manage.py startapp comment
```

## 注册APP
```python
INSTALLED_APPS = [
    ...
    # 新增'comment'代码，激活app
    'comment',
]
```

为了显示发表评论的时间为中国时间，修改时区设置TIME_ZONE为上海的时区。
```diff
- TIME_ZONE = "UTC"
+ TIME_ZONE = 'Asia/Shanghai'
```

# 定义模型
```python
from django.db import models
from django.contrib.auth.models import User
from article.models import Article
 
# 博文的评论
class Comment(models.Model):
    article = models.ForeignKey(Article,
        on_delete=models.CASCADE,
        related_name='comments'
    )
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='comments'
    )
    body = models.TextField()
    created = models.DateTimeField(auto_now_add=True)
 
    class Meta:
        ordering = ('created',)
 
    def __str__(self):
        return self.body[:20]
```

在模型中我们定义了两个外键

- article是被评论的文章 ---> 指向文章表格中的主键"article_id"
- user是评论的发布者    ---> 指向用户表格中的主键"user_id"

公共关键字在一个关系中是主关键字，而在另一个关系中作为外键，起到关联两个关系的作用。

# 对数据进行迁移
![](https://img-blog.csdnimg.cn/img_convert/48eea01552ae773797f9fe357093e3df.png)

# 创建表单
新建一个评论表单
```python
from django import forms
from .models import Comment
 
class CommentForm(forms.ModelForm):
    class Meta:
        model = Comment
        fields = ['body']
```

评论表中，有两个字段属于外键，针对外键字段，Django的内部逻辑是可以自动和外部数据表关联生成。

我们在表单中实际只需要前台处理body字段就可以了。

# 创建视图
评论的视图函数如下：
```python
from django.shortcuts import render, get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from django.http import HttpResponse
 
from application.models import Article
from .forms import CommentForm
 
# 文章评论
@login_required(login_url='/login/')
def post_comment(request, article_id):
    article = get_object_or_404(Article, id=article_id)
    # 处理 POST 请求
    if request.method == 'POST':
        comment_form = CommentForm(request.POST)
        if comment_form.is_valid():
            new_comment = comment_form.save(commit=False)
            new_comment.article = article
            new_comment.user = request.user
            new_comment.save()
            return redirect(article)
        else:
            return HttpResponse("表单内容有误，请重新填写。")
    # 处理错误请求
    else:
        return HttpResponse("发表评论仅接受POST请求。")
```

`get_object_or_404()`：它和`Model.objects.get()`的功能基本是相同的。区别是在生产环境下，如果用户请求一个不存在的对象时，`Model.objects.get()`会返回**Error 500（服务器内部错误）**，而`get_object_or_404()`会返回**Error 404**。相比之下，**返回404错误更加的准确**。

`redirect()`：返回到一个适当的url中：**即用户发送评论后，重新定向到文章详情页面。**当其参数是一个Model对象时，会自动调用这个Model对象的`get_absolute_url()`方法。因此接下来马上修改article的模型。

# 创建URL
在django4blog/urls.py新增评论管理URL：
```python
...
import comment.views
 
urlpatterns = [
    ...
    # 增加评论管理
    path('post-comment/<int:article_id>/', comment.views.post_comment, name='post_comment' ),
]
```